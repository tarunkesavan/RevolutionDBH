#include "treeseg.h"

#include <pcl/io/pcd_io.h>
#include <pcl/common/common.h>
#include <iomanip>
#include <pcl/common/centroid.h>
#include <fstream>
#include <vector>
#include <cmath>
#include <Eigen/Dense>
#include <ctime>
#include <algorithm>
#include "xlsxwriter.h"
#include <iostream>
#include <filesystem>
#include <pcl/point_types.h>
#include <Python.h>
#include <string>
#include <nlohmann/json.hpp>

std::ofstream outFile;
namespace fs = std::filesystem;

// Add at the top with other includes:
struct CylinderMesh {
    std::vector<Eigen::Vector3f> vertices;
    std::vector<std::vector<int>> faces;
};

CylinderMesh generateCylinderMeshData(
    const Eigen::Vector3f& center,
    const Eigen::Vector3f& axis,
    float radius, 
    float height,
    int numTheta = 36,
    int numHeight = 2) { // Reduced number of height segments

    CylinderMesh mesh;
    
    // More robust coordinate system construction
    Eigen::Vector3f up = axis.normalized();
    Eigen::Vector3f right;
    
    // Find least aligned global axis to use for right vector
    float dotX = std::abs(up.dot(Eigen::Vector3f::UnitX()));
    float dotY = std::abs(up.dot(Eigen::Vector3f::UnitY()));
    float dotZ = std::abs(up.dot(Eigen::Vector3f::UnitZ()));
    
    if (dotX <= dotY && dotX <= dotZ) {
        right = up.cross(Eigen::Vector3f::UnitX()).normalized();
    } else if (dotY <= dotX && dotY <= dotZ) {
        right = up.cross(Eigen::Vector3f::UnitY()).normalized();
    } else {
        right = up.cross(Eigen::Vector3f::UnitZ()).normalized();
    }
    
    Eigen::Vector3f forward = right.cross(up).normalized();

    // Generate points
    float halfHeight = height * 0.5f;
    for (int h = 0; h <= numHeight; ++h) {
        float z = -halfHeight + height * h / numHeight;
        
        for (int t = 0; t < numTheta; ++t) {
            float theta = 2.0f * M_PI * t / numTheta;
            float x = radius * cos(theta);
            float y = radius * sin(theta);
            
            Eigen::Vector3f point = center + 
                z * up +
                (x * right + y * forward);
                
            mesh.vertices.push_back(point);
        }
    }

    // Generate faces (triangles)
    for (int h = 0; h < numHeight; ++h) {
        for (int t = 0; t < numTheta; ++t) {
            int current = h * numTheta + t;
            int next = h * numTheta + ((t + 1) % numTheta);
            int above = (h + 1) * numTheta + t;
            int aboveNext = (h + 1) * numTheta + ((t + 1) % numTheta);
            
            // Two triangles per quad
            mesh.faces.push_back({current, next, aboveNext});
            mesh.faces.push_back({current, aboveNext, above});
        }
    }
	
    return mesh;
}

void writeCombinedMeshes(const std::vector<CylinderMesh>& meshes, const std::string& filename) {
    std::ofstream out(filename);
    if (!out.is_open()) {
        std::cerr << "Error: Could not open file " << filename << std::endl;
        return;
    }
    
    // Count total vertices and faces
    size_t totalVertices = 0;
    size_t totalFaces = 0;
    for (const auto& mesh : meshes) {
        totalVertices += mesh.vertices.size();
        totalFaces += mesh.faces.size();
    }
    
    // Write header with more standard PLY format
    out << std::fixed << std::setprecision(6);
    out << "ply\n";
    out << "format ascii 1.0\n";
    out << "comment Generated by treeseg\n";
    out << "element vertex " << totalVertices << "\n";
    out << "property float x\n";
    out << "property float y\n";
    out << "property float z\n";
    out << "property uchar red\n";    // Add color properties
    out << "property uchar green\n";
    out << "property uchar blue\n";
    out << "element face " << totalFaces << "\n";
    out << "property list uchar int vertex_indices\n"; // Corrected type to int
    out << "end_header\n";

    // Write vertices with colors
    for (const auto& mesh : meshes) {
        for (const auto& v : mesh.vertices) {
            // Write vertex coordinates
            out << v.x() << " " << v.y() << " " << v.z() << " "
                // Add fixed color (light gray) for better visibility
                << "200 200 200\n";
        }
    }

    // Write faces with proper indexing
    size_t vertexOffset = 0;
    for (const auto& mesh : meshes) {
        for (const auto& face : mesh.faces) {
            if (face.size() == 3) {  // Ensure we only write triangles
                out << "3 " 
                    << (face[0] + vertexOffset) << " "
                    << (face[1] + vertexOffset) << " "
                    << (face[2] + vertexOffset) << "\n";
            }
        }
        vertexOffset += mesh.vertices.size();
    }
    
    out.close();
}
// Forward declaration of the readClouds function
std::vector<pcl::PointCloud<PointTreeseg>::Ptr> readClouds(const std::string &fname);

void initParameterPrinting(const std::string& filename = "cylinder_parameters.txt") {
    outFile.open(filename);
    if (!outFile.is_open()) {
        throw std::runtime_error("Could not open output file");
    }
    // Write headers with fixed width columns
    outFile << std::setw(10) << "IsModel" 
            << std::setw(10) << "Radius" 
            << std::setw(10) << "Length" 
            << std::setw(10) << "StepCov" 
            << std::setw(12) << "RadRatio" 
            << std::setw(10) << "X" 
            << std::setw(10) << "Y" 
            << std::endl;
}

void writeFittingResults(const cylinder &cyl) {
    outFile << std::fixed << std::setprecision(3)
            << std::setw(10) << cyl.ismodel 
            << std::setw(10) << cyl.rad 
            << std::setw(10) << cyl.len 
            << std::setw(10) << cyl.stepcov 
            << std::setw(12) << cyl.radratio 
            << std::setw(10) << cyl.x 
            << std::setw(10) << cyl.y 
            << std::endl;
}

void closeParameterPrinting() {
    if (outFile.is_open()) {
        outFile.close();
    }
}

void exportStemMetricsToExcel(const std::vector<std::pair<cylinder,CylinderMesh>>& filteredCylinders, const std::vector<int>& indices, const std::string& name = "preds.dbh") {

	// Get current date/time
    time_t now = time(0);
    struct tm tstruct;
    char buf[80];
    tstruct = *localtime(&now);
    strftime(buf, sizeof(buf), "%Y%m%d_%H%M%S", &tstruct);
	std::string nameLower = name;
    std::transform(nameLower.begin(), nameLower.end(), nameLower.begin(), ::tolower);
    
    // Create Excel file
    std::string excel_filename = nameLower + ".preds.dbh." + std::string(buf) + ".xlsx";
    lxw_workbook *workbook = workbook_new(excel_filename.c_str());
    lxw_worksheet *worksheet = workbook_add_worksheet(workbook, NULL);
    
    // Write headers
	worksheet_write_string(worksheet, 0, 0, "X", NULL);
	worksheet_write_string(worksheet, 0, 1, "Y", NULL);
	worksheet_write_string(worksheet, 0, 3, "Center_Z", NULL); // <-- ADD THIS
	worksheet_write_string(worksheet, 0, 4, "Diameter", NULL); // <-- MOVED from col 2
    
    // Create visualization point cloud with proper initialization
    pcl::PointCloud<PointTreeseg>::Ptr vizCloud(new pcl::PointCloud<PointTreeseg>);
    const int numPoints = 36;  // Points per circle
    vizCloud->width = numPoints * indices.size();
    vizCloud->height = 1;
    vizCloud->points.resize(vizCloud->width * vizCloud->height);
    int pointIdx = 0;
    
    // Write data and create visualization points
    int row = 1;
    for(int k : indices) {
        const cylinder& cyl = filteredCylinders[k].first;
        
        // Calculate position at 0.3m height along cylinder axis
		Eigen::Vector3f axis(cyl.dx, cyl.dy, cyl.dz);
        axis.normalize();

		// Ensure axis points upward (align with Z axis)
		if (axis.z() < 0) axis = -axis;
		
        // Calculate bottom point by moving down half the cylinder length from center
        Eigen::Vector3f bottomPoint = Eigen::Vector3f(cyl.x, cyl.y, cyl.z) - (axis * (cyl.len/2.0f));
        // Now calculate point at 0.3m from bottom
        Eigen::Vector3f centerAt03m = bottomPoint + (axis * 0.3f);
        
        // Write to Excel
    	worksheet_write_number(worksheet, row, 0, centerAt03m[0], NULL); // X
    	worksheet_write_number(worksheet, row, 1, centerAt03m[1], NULL); // Y
    	worksheet_write_number(worksheet, row, 2, centerAt03m[2], NULL); // <-- ADD THIS (Z at 0.3m)
    	worksheet_write_number(worksheet, row, 3, cyl.z, NULL);         // <-- ADD THIS (Center Z)
    	worksheet_write_number(worksheet, row, 4, cyl.rad * 2, NULL);   // <-- MOVED from col 2

        // Create circle of points for visualization
		for (int i = 0; i < numPoints; ++i) {
            float angle = 2.0f * M_PI * i / numPoints;
            
            // Find perpendicular vectors to create circle in correct orientation
            Eigen::Vector3f up = axis.normalized();
            Eigen::Vector3f right;
            
            // Find least aligned global axis to use for right vector
            float dotX = std::abs(up.dot(Eigen::Vector3f::UnitX()));
            float dotY = std::abs(up.dot(Eigen::Vector3f::UnitY())); 
            float dotZ = std::abs(up.dot(Eigen::Vector3f::UnitZ()));
            
            if (dotX <= dotY && dotX <= dotZ) {
                right = up.cross(Eigen::Vector3f::UnitX()).normalized();
            } else if (dotY <= dotX && dotY <= dotZ) {
                right = up.cross(Eigen::Vector3f::UnitY()).normalized();
            } else {
                right = up.cross(Eigen::Vector3f::UnitZ()).normalized();
            }
            
            Eigen::Vector3f forward = right.cross(up).normalized();
            
            // Create circle point in correct orientation
            Eigen::Vector3f circlePoint = centerAt03m + 
                (cyl.rad * cos(angle) * right + 
                 cyl.rad * sin(angle) * forward);
                 
            vizCloud->points[pointIdx].x = circlePoint.x();
            vizCloud->points[pointIdx].y = circlePoint.y();
            vizCloud->points[pointIdx].z = circlePoint.z();
            pointIdx++;
        }

        row++;
    }
    
    workbook_close(workbook);
    // std::cout << "Predictions are here: "<< excel_filename << std::endl;

    pcl::PCDWriter writer;
    std::string viz_filename = nameLower + ".preds.dbh." + std::string(buf) + ".pcd";
    writer.write(viz_filename, *vizCloud, false);
	// std::cout << "                      " << viz_filename << std::endl;
}
// ADD THE JSON EXPORT FUNCTION HERE
void exportStemMetricsToJSON(
	const std::vector<std::pair<cylinder,CylinderMesh>>& filteredCylinders,
	const std::vector<int>& indices,
	const std::string& name = "preds.dbh") {

	using json = nlohmann::json;

	// Get current date/time
	time_t now = time(0);
	struct tm tstruct;
	char buf[80];
	tstruct = *localtime(&now);
	strftime(buf, sizeof(buf), "%Y%m%d_%H%M%S", &tstruct);

	std::string nameLower = name;
	std::transform(nameLower.begin(), nameLower.end(), nameLower.begin(), ::tolower);

	// Create JSON structure
	json output;
	output["metadata"] = {
		{"timestamp", std::string(buf)},
		{"name", nameLower},
		{"count", indices.size()}
	};

	json stems = json::array();

	for(int k : indices) {
		const cylinder& cyl = filteredCylinders[k].first;

		// Calculate position at 0.3m height
		Eigen::Vector3f axis(cyl.dx, cyl.dy, cyl.dz);
		axis.normalize();
		if (axis.z() < 0) axis = -axis;

		Eigen::Vector3f bottomPoint = Eigen::Vector3f(cyl.x, cyl.y, cyl.z) - (axis * (cyl.len/2.0f));
		Eigen::Vector3f centerAt03m = bottomPoint + (axis * 0.3f);

		json stem = {
			{"x", centerAt03m[0]},
		  {"y", centerAt03m[1]},
		  {"center_z", cyl.z},
		  {"Diameter", cyl.rad * 2}
		};

		stems.push_back(stem);
	}

	output["stems"] = stems;

	// Write to file
	std::string json_filename = nameLower + ".preds.dbh." + std::string(buf) + ".json";
	std::ofstream file(json_filename);
	file << output.dump(4); // Pretty print with 4 space indent
	file.close();

	std::cout << "JSON saved: " << json_filename << std::endl;
}


void saveRegionsToFile(const std::vector<std::vector<int>>& regions, const std::string& filename = "regions.txt") {
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open file " << filename << " to save regions." << std::endl;
        return;
    }

    for (size_t i = 0; i < regions.size(); ++i) {
        file << "Region " << i << ": ";
        for (size_t j = 0; j < regions[i].size(); ++j) {
            file << regions[i][j];
            if (j < regions[i].size() - 1) file << ", ";
        }
        file << "\n";
    }

    file.close();
    // std::cout << "Regions saved to " << filename << std::endl;
}

void saveRegionsToPCD(const std::vector<pcl::PointCloud<PointTreeseg>::Ptr>& regions, const std::string& directory = "./") {
    for (size_t i = 0; i < regions.size(); ++i) {
        std::stringstream filename;
        filename << directory << "region_" << i << ".pcd";
        
        if (pcl::io::savePCDFileBinary(filename.str(), *regions[i]) == -1) {
            std::cerr << "Failed to save region " << i << " to " << filename.str() << std::endl;
        } 
    }
}


// void filter_pcd_files(const std::string& input_dir, const std::string& output_dir, float min_height, float min_width, float maxwidth) {
//     for (const auto& entry : fs::directory_iterator(input_dir)) {
//         if (entry.path().extension() == ".pcd") {
//             std::string filepath = entry.path().string();
//             pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);

//             if (pcl::io::loadPCDFile<pcl::PointXYZ>(filepath, *cloud) == -1) {
//                 std::cerr << "Failed to load: " << filepath << std::endl;
//                 continue;
//             }

//             float min_z = std::numeric_limits<float>::max();
//             float max_z = std::numeric_limits<float>::lowest();
//             float min_x = std::numeric_limits<float>::max();
//             float max_x = std::numeric_limits<float>::lowest();

//             for (const auto& point : cloud->points) {
//                 if (!std::isfinite(point.x) || !std::isfinite(point.z)) continue;

//                 if (point.z < min_z) min_z = point.z;
//                 if (point.z > max_z) max_z = point.z;
//                 if (point.x < min_x) min_x = point.x;
//                 if (point.x > max_x) max_x = point.x;
//             }

//             float height = max_z - min_z;
//             float width = max_x - min_x;

//             std::cout << "File: " << entry.path().filename() << " | Height: " << height << ", Width: " << width << std::endl;

//             if (height >= min_height && width >= min_width && width <= maxwidth) {
//                 std::string output_path = fs::path(output_dir) / entry.path().filename();
//                 pcl::io::savePCDFileBinary(output_path, *cloud);
//                 std::cout << "Saved to: " << output_path << std::endl;
//             }
//         }
//     }
// }


template <typename PointT>
bool isRegionWithinSizeLimits(typename pcl::PointCloud<PointT>::Ptr cloud, float minHeight, float minWidth, float maxWidth, float& outHeight, float& outWidth) {
    Eigen::Vector4f minPt, maxPt;
    pcl::getMinMax3D(*cloud, minPt, maxPt);

    outHeight = maxPt[2] - minPt[2]; // height (Z)
    outWidth  = maxPt[0] - minPt[0]; // width  (X)

    // return (outHeight >= minHeight && outWidth >= minWidth && outWidth <= maxWidth);
     return (outWidth >= minWidth && outWidth <= maxWidth);
    
}

void filter_pcd_files(const std::string& input_dir, const std::string& output_dir, float min_height, float min_width, float maxwidth) {
    for (const auto& entry : fs::directory_iterator(input_dir)) {
        if (entry.path().extension() == ".pcd") {
            std::string filepath = entry.path().string();
            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);

            if (pcl::io::loadPCDFile<pcl::PointXYZ>(filepath, *cloud) == -1) {
                std::cerr << "Failed to load: " << filepath << std::endl;
                continue;
            }

            float height, width;
            if (isRegionWithinSizeLimits<pcl::PointXYZ>(cloud, min_height, min_width, maxwidth, height, width)) {
                // std::cout << "File: " << entry.path().filename() << " | Height: " << height << ", Width: " << width << std::endl;
                std::string output_path = fs::path(output_dir) / entry.path().filename();
                pcl::io::savePCDFileBinary(output_path, *cloud);
                // std::cout << "Saved to: " << output_path << std::endl;
            }
        }
    }
}

void mergePCDFiles(const std::string& input_folder, const std::string& output_file) {
    pcl::PointCloud<pcl::PointXYZ>::Ptr merged_cloud(new pcl::PointCloud<pcl::PointXYZ>);

    for (const auto& entry : fs::directory_iterator(input_folder)) {
        if (entry.path().extension() == ".pcd") {
            pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
            if (pcl::io::loadPCDFile<pcl::PointXYZ>(entry.path().string(), *cloud) == -1) {
                std::cerr << "Failed to load: " << entry.path() << std::endl;
                continue;
            }

            // std::cout << "Loaded: " << entry.path().filename() << " with " << cloud->size() << " points." << std::endl;
            *merged_cloud += *cloud;
        }
    }

    std::cout << "Saving merged point cloud with " << merged_cloud->size() << " points to: " << output_file << std::endl;
    pcl::io::savePCDFileBinary(output_file, *merged_cloud);
}

bool stringToBool(const std::string& str) {
    std::string s = str;
    std::transform(s.begin(), s.end(), s.begin(), ::tolower); // normalize case

    if (s == "true" || s == "1" || s == "yes" || s == "y") {
        return true;
    } else if (s == "false" || s == "0" || s == "no" || s == "n") {
        return false;
    } 
}


int main(int argc, char **argv)
{
	std::vector<std::string> args(argv+1,argv+argc);
	//
	pcl::PCDReader reader;
	pcl::PCDWriter writer;
	std::stringstream ss;

	std::vector<std::string> id = getFileID(args[8]);

	//
    bool runClusterExtraction = false;
    bool runRegionBasedSegmentation = false;
    bool runVerticalityClassification = false;
    bool runRansacCylinderFits = false;
    bool applyFilter = false;
    bool applyGCC = false;

    // Intiate Python interpreter 


    if (args.size() < 10) {
        std::cerr << "Usage: " << argv[0] << " <smoothness> <dmin> <dmax> <nmin> <nncluster> <lmin> <stepcovmax> <radratiomin> <coordfile> <pcdfile> [steps...]" << std::endl;
        std::cerr << "  smoothness: Smoothness threshold for region-based segmentation, default 10" << std::endl;
        std::cerr << "  dmin: Minimum stem diameter to consider, default 0.1m" << std::endl;
        std::cerr << "  dmax: Maximum stem diameter to consider, default 1m" << std::endl;
        std::cerr << "  nmin: Minimum number of points required for a valid cluster in euclideanClustering, default 100" << std::endl;
        std::cerr << "  nncluster: Number of nearest neighbors to consider when calculating clustering distance threshold, default 18" << std::endl;
        std::cerr << "  lmin: Minimum cylinder length to consider, default 1m" << std::endl;
        std::cerr << "  stepcovmax: Uniformity of point distribution along cylinder height, default 0.1." << std::endl;
		std::cerr << "  radratiomin: Consistency of cyliners radius along cylinder height, default 0.9." << std::endl;
        std::cerr << "  coordfile: File with region coordinates (xmin, xmax, ymin, ymax)" << std::endl;
        std::cerr << "  pcdfile: Input point cloud file (.pcd)" << std::endl;
        std::cerr << "  steps: Optional processing steps to run (ClusterExtraction, RegionBasedSegmentation, VerticalityClassification, RansacCylinderFits)" << std::endl;
        std::cerr << "  Apply filter flag" << std::endl;
        std::cerr << "  Apply GCC flag" << std::endl;

        std::cerr << "Example: findstems 10 0.1 1.0 100 18 1.0 0.1 0.9 ../NOU11.coords.dat ../NOU11.slice.pcd ClusterExtraction RegionBasedSegmentation VerticalityClassification RansacCylinderFits true true" << std::endl;
        return -1;
    }

    for (size_t i = 10; i < args.size(); ++i) {
        if (args[i] == "ClusterExtraction") {
            runClusterExtraction = true;
        } else if (args[i] == "RegionBasedSegmentation") {
            runRegionBasedSegmentation = true;
        } else if (args[i] == "VerticalityClassification") {
            runVerticalityClassification = true;
        } else if (args[i] == "RansacCylinderFits") {
            runRansacCylinderFits = true;
        } 
    }

   
    if (stringToBool(args[14])) {
        applyFilter = true;
    } 
    if (stringToBool(args[15])) {
        applyGCC = true;
    }

    
    std::cout << applyFilter << " ,CHECK> " << applyGCC << " ***********************3" << std::endl;
 

	//
	std::cout << "Cluster extraction: " << std::flush;
	std::vector<pcl::PointCloud<PointTreeseg>::Ptr> clusters;
	int nmin = std::stoi(args[3]); // Minimum number of points required for a valid cluster
	int nncluster = std::stoi(args[4]); // Number of nearest neighbors for clustering distance calculation
	ss.str("");
	ss << id[0] << ".intermediate.slice.clusters.pcd";
	if (runClusterExtraction) {
		std::cout << "Reading slice: " << std::flush;
		pcl::PointCloud<PointTreeseg>::Ptr slice(new pcl::PointCloud<PointTreeseg>);
		reader.read(args[9],*slice);
		std::cout << "complete" << std::endl;
		std::vector<float> nndata = dNN(slice,nncluster);
		std::cout << "Clustering distance threshold (dmax): " << nndata[0] << std::endl;
		euclideanClustering(slice,nndata[0],nmin,clusters);
		writeClouds(clusters,ss.str(),false);
		std::cout << ss.str() << " writing | " << clusters.size() << std::endl;
	} else {
		std::cout << ss.str() << " reading ..." << std::endl;
		clusters = readClouds(ss.str());
		std::cout << ss.str() << " | " << clusters.size() << std::endl;
	}

	//
	std::cout << "Region-based segmentation: " << std::endl;
	std::vector<pcl::PointCloud<PointTreeseg>::Ptr> regions;
	pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
	float smoothness = std::stof(args[0]);
	ss.str("");
	ss << id[0] << ".intermediate.slice.clusters.regions.pcd";

	if (runRegionBasedSegmentation) {
		for(int i=0;i<clusters.size();i++)
		{
			std::vector<pcl::PointCloud<PointTreeseg>::Ptr> tmpregions;
			int nneighbours;
			int nmax;
			float curvature;
			// printProgressBar(i, clusters.size());
			estimateNormals(clusters[i],50.0,normals);
			nneighbours = 250;						// MARTIN Controls number of neighbors considered when growing regions, default 250
													// Higher values:
													// 		- Larger search radius
													// 		- More connected regions
													// 		- Smoother boundaries
													// 		- Slower processing
													// Lower values:
													// 		- More segmented regions
													// 		- Faster processing
													// 		- May miss connections
			nmin = 100;								// MARTIN Sets minimum number of points required for a valid region, , default 100
			nmax = std::numeric_limits<int>::max();	// MARTIN Sets maximum number of points allowed in a region
			curvature = 2;							// MARTIN Used to determine if points belong to same region, Controls region boundary decisions, , default 2
													// Lower values:
													// 		- More strict segmentation
													// 		- Only very smooth surfaces grouped together
													// 		- More regions created
													// Higher values:
													// 		- More tolerant segmentation
													// 		- Can group more curved surfaces together
													// 		- Fewer, larger regions
			regionSegmentation(clusters[i],normals,nneighbours,nmin,nmax,smoothness,curvature,tmpregions);
			for(int j=0;j<tmpregions.size();j++) regions.push_back(tmpregions[j]);
			normals->clear();
		}
		std::cout << std::endl;
		writeClouds(regions,ss.str(),false);
		std::cout << ss.str() << " writing | " << regions.size() << std::endl;
	} else {
		std::cout << ss.str() << " reading ..." << std::endl;
		regions = readClouds(ss.str());
		std::cout << ss.str() << " | " << regions.size() << std::endl;
	}

    if (runVerticalityClassification) {
        // std::cout << "Verticality classification: " << std::endl;
        regions = classifyVerticalRegions(regions, 40.0, 0.4);	// angle from vertical axis, ration of vertical points 
        ss.str("");
        ss << id[0] << ".intermediate.slice.clusters.regions.vertical.pcd";
        writeClouds(regions, ss.str(), false);
        std::cout << ss.str() << " writing | " << regions.size() << std::endl;
    } else {
        ss.str("");
        ss << id[0] << ".intermediate.slice.clusters.regions.vertical.pcd";
        std::cout << ss.str() << " reading ..." << std::endl;
        regions = readClouds(ss.str());
        std::cout << ss.str() << " | " << regions.size() << std::endl;
    }

    std::vector<std::vector<int>> regionIndices;
    for (const auto& cloudPtr : regions) {
        std::vector<int> indices;
        for (size_t i = 0; i < cloudPtr->size(); ++i) {
            indices.push_back(static_cast<int>(i));
        }
        regionIndices.push_back(indices);
    }


    // New filtering and merging code by Rajesh starts here
    std::string pcdPath = argv[9]; // assuming ../NOU11.slice.pcd is args[9]

    fs::path originalPath(pcdPath);
    fs::path parentDir = originalPath.parent_path(); // gets ../
    fs::path outprocessDir = parentDir / "cluster/regions/"; // ../outprocess
    fs::path outprocessDir_final = parentDir / "cluster/regions/filtered/"; // ../outprocess
    fs::path classifierOutput = parentDir / "cluster/regions/GCC.txt"; // ../outprocess

    std::string input_folder = outprocessDir;
    std::string output_folder = outprocessDir_final;
    float minHeight = 1.0f; // Minimum height (Z)
    float minWidth = 0.1f;  // Minimum width (X)
    float maxwidth = 3.0f;  // Maximum width (X)
     if (!fs::exists(output_folder)) {
        fs::create_directories(output_folder);
    }

    //======================= can be commented start==========================
    if (!fs::exists(input_folder)) {
        fs::create_directories(input_folder);
    }
    //Save regions to PCD files - this is only for testing and can be removed in future
    saveRegionsToPCD(regions, input_folder); 
    filter_pcd_files(input_folder, output_folder, minHeight, minWidth,maxwidth);
    std::string input_folder_m = output_folder;
    std::string output_file_m = output_folder + "/filtered_and_merged_reference_file.pcd";
    mergePCDFiles(input_folder_m, output_file_m);
    //======================= can be commented end==========================


    // PYTHON CODE RUN STARTS HERE==================
	PyObject* pModule = nullptr;
    if (applyGCC) {
    Py_Initialize();
    PyRun_SimpleString("import sys");
    PyRun_SimpleString("sys.path.append('/Users/srnambur/Desktop/R-Evolution@Latest/AI_DBH_Analysis/Tarun_classifier')");
    PyRun_SimpleString("print('sys.path:', sys.path)");

    PyObject* pName = PyUnicode_FromString("ml-pipeline-gc-classifier-v3");
    pModule = PyImport_Import(pName);  // ✅ REMOVE the type declaration here!

    std::vector<pcl::PointCloud<PointTreeseg>::Ptr> classifiedRegions;

    if (pModule) {
        PyObject* pFunc = PyObject_GetAttrString(pModule, "classify_pcd_folder");
        if (pFunc && PyCallable_Check(pFunc)) {
            PyObject* pArgs = PyTuple_Pack(1, PyUnicode_FromString(input_folder.c_str()));
            PyObject* pValue = PyObject_CallObject(pFunc, pArgs);
            std::vector<std::map<std::string, std::string>> result;
            Py_DECREF(pArgs);

            if (PyList_Check(pValue)) {
                Py_ssize_t list_size = PyList_Size(pValue);
                PyObject* repr = PyObject_Repr(pValue);
                if (repr && PyUnicode_Check(repr)) {
                    const char* dictStr = PyUnicode_AsUTF8(repr);
                    std::ofstream outFile(classifierOutput);
                    if (outFile.is_open()) {
                        outFile << dictStr;
                        outFile.close();
                    } else {
                        std::cerr << "Failed to open file: " << classifierOutput << std::endl;
                    }
                    Py_DECREF(repr);
                } else {
                    std::cerr << "Failed to convert PyDict to string." << std::endl;
                }

                for (Py_ssize_t i = 0; i < list_size; ++i) {
                    PyObject* pyDict = PyList_GetItem(pValue, i);
                    if (PyDict_Check(pyDict)) {
                        std::map<std::string, std::string> cppDict;
                        PyObject* pathValue = PyDict_GetItemString(pyDict, "file");
                        if (pathValue && PyUnicode_Check(pathValue)) {
                            const char* pathStr = PyUnicode_AsUTF8(pathValue);
                            if (pathStr) {
                                fs::path full_path = fs::path(input_folder) / pathStr;
                                std::string full_path_str = full_path.string();
                                pcl::PointCloud<PointTreeseg>::Ptr cloud(new pcl::PointCloud<PointTreeseg>);
                                if (pcl::io::loadPCDFile<PointTreeseg>(full_path_str, *cloud) == -1) {
                                    PCL_ERROR("Couldn't read file %s \n", full_path_str.c_str());
                                    continue;
                                }
                                classifiedRegions.push_back(cloud);
                            }
                        }
                    }
                }
                Py_DECREF(pValue);
            } else {
                PyErr_Print();
            }
            Py_XDECREF(pFunc);
        } else {
            PyErr_Print();
        }
        Py_DECREF(pModule);
    } else {
        std::cerr << "Failed to load Python module!" << std::endl;
        PyErr_Print();
    }

    std::cout << "Number of classified regions: " << classifiedRegions.size() << std::endl;
    std::cout << "Python module loaded and executed successfully." << std::endl;
    regions = classifiedRegions;

    Py_Finalize();  // ✅ Move this INSIDE the if block!
}

    if (applyFilter) {
        std::vector<pcl::PointCloud<PointTreeseg>::Ptr> filteredRegions;
            int regionIndex = 0;

            for (const auto& region : regions) {
                float height, width;
                if (isRegionWithinSizeLimits<PointTreeseg>(region, minHeight, minWidth, maxwidth, height, width)) {
                    // std::cout << "Region " << regionIndex << ": Height = " << height << ", Width = " << width << std::endl;
                    filteredRegions.push_back(region);
                }
                regionIndex++;
            }
             std::cout << "Number of filteredRegions regions: " << filteredRegions.size() << std::endl;
            regions = filteredRegions;
    }

    
    // std::vector<pcl::PointCloud<PointTreeseg>::Ptr> filteredRegions;
    // int regionIndex = 0;
    // for (const auto& region : regions) {
    //     Eigen::Vector4f minPt, maxPt;
    //     pcl::getMinMax3D(*region, minPt, maxPt);

    //     float height = maxPt[2] - minPt[2]; // Z-axis height
    //     float width = maxPt[0] - minPt[0];  // X-axis width only
    //     std::cout << "Rajesh Region " << regionIndex << ": Height = " << height << ", Width = " << width << std::endl;
    //      if (height >= minHeight && width >= minWidth && width <= maxwidth) {
    //         filteredRegions.push_back(region);
    //     }
    //      filteredRegions.push_back(region);
    //      regionIndex++;
    // }
    // std::cout << "Filtered regions (after height >= " << minHeight 
    //         << " and X-width >= " << minWidth << "): " 
    //         << filteredRegions.size() << std::endl;



    


    // pcl::PointCloud<PointTreeseg>::Ptr combinedCloud(new pcl::PointCloud<PointTreeseg>);
    // for (const auto& region : filteredRegions) {
    //     *combinedCloud += *region;  // Now both are of type PointCloud<PointTreeseg>
    // }
    // // We are already saving this kind of file, only diff is above we are directly merging files and generating output, here filtering regions through code and saving. but both must be same
    // pcl::io::savePCDFileBinary(output_folder+"/filtered_regions_combined.pcd", *combinedCloud);




	// std::cout << "RANSAC cylinder fits: " << std::endl;
	std::vector<cylinder> allCylinders;
	float dmin = std::stof(args[1]);
	float dmax = std::stof(args[2]);
    float lmin = std::stof(args[5]); // Parse lmin from command-line arguments
    float stepcovmax = std::stof(args[6]); // Parse stepcovmax from command-line arguments
    float radratiomin = std::stof(args[7]); // Parse radratiomin from command-line arguments

	std::ifstream coordfile;
	coordfile.open(args[8]);
	float coords[4];
	int n = 0;
	if(coordfile.is_open())
	{
		while(!coordfile.eof())
		{
			coordfile >> coords[n];
			n++;
		}
	}
	coordfile.close();
	float xmin = coords[0];
	float xmax = coords[1];
	float ymin = coords[2];
	float ymax = coords[3];
	
	int nnearest = 60;

	std::vector<cylinder> validCylinders;
	if (runRansacCylinderFits) {
		for(int i=0; i<regions.size(); i++) {
			// printProgressBar(i, regions.size());
			cylinder cyl;
			fitCylinder(regions[i], nnearest, true, true, cyl);
			allCylinders.push_back(cyl);
		}
		std::cout << "Fitted all cylinders." << std::endl;
		
		// Write both point clouds and parameters
		std::cout << "Preparing valid cylinders for saving ..." << std::endl;
		std::vector<pcl::PointCloud<PointTreeseg>::Ptr> cylsPointsToWrite;
		for(const auto& cyl : allCylinders) {
			if (cyl.inliers != nullptr && 
				cyl.inliers->points.size() > 0  &&
				cyl.ismodel) {
				validCylinders.push_back(cyl);
				cylsPointsToWrite.push_back(cyl.inliers);
			}
		}
		std::cout << "Ready to save cylinder parameters and points." << std::endl;
		ss.str("");
		ss << id[0] << ".intermediate.slice.clusters.regions.allcylinders.pcd";
		writeClouds(cylsPointsToWrite, ss.str(), false);
		// std::cout << ss.str() << " | " << cylsPointsToWrite.size() << std::endl;
		// Write parameters
		ss.str("");
		ss << id[0] << ".intermediate.slice.clusters.regions.allcylinders.params";
		writeCylinderParameters(validCylinders, ss.str());
		// std::cout << ss.str() << " | " << validCylinders.size() << std::endl;
		
	} else {
		ss.str("");
		ss << id[0] << ".intermediate.slice.clusters.regions.allcylinders.pcd";
		std::cout << ss.str() << " reading ..." << std::endl;
		std::vector<pcl::PointCloud<PointTreeseg>::Ptr> loadedCyls = readClouds(ss.str());
		std::cout << ss.str() << " | " << loadedCyls.size() << std::endl;
		ss.str("");
		ss << id[0] << ".intermediate.slice.clusters.regions.allcylinders.params";
		validCylinders = readCylinderParameters(ss.str());
		std::cout << ss.str() << " | " << validCylinders.size() << std::endl;
		// Combine point clouds with parameters
		for(size_t i = 0; i < validCylinders.size(); i++) {
			validCylinders[i].inliers = loadedCyls[i];
		}
		std::cout << "Read all cylinder parameters and points." << std::endl;
	}

	//
	// std::cout << "Filtering cylinders..." << std::endl;

	// Print filtering parameters in a table format
	// printFilteringParameters(dmin, dmax, lmin, stepcovmax, radratiomin, xmin, xmax, ymin, ymax);

	// Add statistics tracking
	std::map<std::string, int> filterStats = {
	    {"ismodel", 0}, {"dmin", 0}, {"dmax", 0}, {"lmin", 0},
	    {"stepcovmax", 0}, {"radratiomin", 0}, {"xmin", 0},
	    {"xmax", 0}, {"ymin", 0}, {"ymax", 0}
	};
	std::map<std::string, float> filterSums = {
	    {"dmin", 0.0f}, {"dmax", 0.0f}, {"lmin", 0.0f},
	    {"stepcovmax", 0.0f}, {"radratiomin", 0.0f}, {"xmin", 0.0f},
	    {"xmax", 0.0f}, {"ymin", 0.0f}, {"ymax", 0.0f}
	};

	std::vector<std::pair<cylinder,CylinderMesh>> filteredCylinders;
	
	for(int i=0; i<validCylinders.size(); i++) {
		// printProgressBar(i, validCylinders.size());
		const cylinder& cyl = validCylinders[i];

		if(cyl.ismodel) 
		{
			 // Generate cylinder mesh using actual cylinder parameters
			CylinderMesh mesh = generateCylinderMeshData(
				Eigen::Vector3f(cyl.x, cyl.y, cyl.z),  // Use cylinder base
				Eigen::Vector3f(cyl.dx, cyl.dy, cyl.dz),  // Use actual cylinder axis
				cyl.rad,
				cyl.len,
				36,
				2
			);
			
			filteredCylinders.push_back(std::make_pair(cyl, mesh));
		} else {
			// Update statistics for rejected cylinders
			if(!cyl.ismodel) filterStats["ismodel"]++;
			else if(cyl.rad*2 < dmin) { filterStats["dmin"]++; filterSums["dmin"] += cyl.rad*2; }
			else if(cyl.rad*2 > dmax) { filterStats["dmax"]++; filterSums["dmax"] += cyl.rad*2; }
			else if(cyl.len < lmin) { filterStats["lmin"]++; filterSums["lmin"] += cyl.len; }
			else if(cyl.stepcov > stepcovmax) { filterStats["stepcovmax"]++; filterSums["stepcovmax"] += cyl.stepcov; }
			else if(cyl.radratio <= radratiomin) { filterStats["radratiomin"]++; filterSums["radratiomin"] += cyl.radratio; }
			else if(cyl.x < xmin) { filterStats["xmin"]++; filterSums["xmin"] += cyl.x; }
			else if(cyl.x > xmax) { filterStats["xmax"]++; filterSums["xmax"] += cyl.x; }
			else if(cyl.y < ymin) { filterStats["ymin"]++; filterSums["ymin"] += cyl.y; }
			else if(cyl.y > ymax) { filterStats["ymax"]++; filterSums["ymax"] += cyl.y; }
		}
	}

	// Write all meshes and point clouds
	ss.str("");
	ss << id[0] << ".intermediate.slice.clusters.regions.cylinders.mesh.ply";
	std::vector<CylinderMesh> meshes;
	for(const auto& p : filteredCylinders) {
		meshes.push_back(p.second);
	}
	writeCombinedMeshes(meshes, ss.str());
	
	ss.str("");
	ss << id[0] << ".intermediate.slice.clusters.regions.cylinders.pcd";
	std::vector<pcl::PointCloud<PointTreeseg>::Ptr> clouds;
	for(const auto& p : filteredCylinders) {
		clouds.push_back(p.first.inliers);
	}
	writeClouds(clouds, ss.str(), false);
	// std::cout << ss.str() << " | " << clouds.size() << std::endl;

	// Print filtering statistics
	// printFilteringStatistics(filterStats, filterSums);

	// Verticality filtering using actual cylinder axis
	std::cout << "Verticality filtering (35 degree threshold): " << std::endl;
	float anglemax = 35;
	std::vector<int> idx;
	
	for(int j=0; j < filteredCylinders.size(); j++) {
		// printProgressBar(j, filteredCylinders.size());
		
		const cylinder& cyl = filteredCylinders[j].first;
		
		// Use cylinder's actual fitted axis direction
		Eigen::Vector4f cylinder_axis(cyl.dx, cyl.dy, cyl.dz, 0);
		cylinder_axis.normalize();
		
		// Calculate acute angle from vertical
		float angle = pcl::getAngle3D(cylinder_axis, Eigen::Vector4f(0,0,1,0)) * (180/M_PI);
		if (angle > 90) angle = 180 - angle;
		
		if(angle <= anglemax) idx.push_back(j);
	}

	// Write vertical filtered results
	std::vector<CylinderMesh> verticalMeshes;
	std::vector<pcl::PointCloud<PointTreeseg>::Ptr> verticalClouds;
	for(int k=0; k < idx.size(); k++) {
		verticalMeshes.push_back(filteredCylinders[idx[k]].second);
		verticalClouds.push_back(filteredCylinders[idx[k]].first.inliers);
	}

	ss.str("");
	ss << id[0] << ".intermediate.slice.clusters.regions.cylinders.vertical.pcd";
	writeClouds(verticalClouds, ss.str(), false);
	// std::cout << ss.str() << " | " << verticalClouds.size() << std::endl;

	ss.str("");
	ss << id[0] << ".intermediate.slice.clusters.regions.cylinders.vertical.mesh.ply";
	writeCombinedMeshes(verticalMeshes, ss.str());
	// std::cout <<  ss.str() << " | " << verticalMeshes.size() << std::endl;

	// Extract metrics and write to Excel
	exportStemMetricsToExcel(filteredCylinders, idx, id[0]);

	exportStemMetricsToJSON(filteredCylinders, idx, id[0]);

	return 0;
}
